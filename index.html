<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Tempo de Conferência</title>
<style>
        /* CSS para o tema ALL-BLACK */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a; /* Fundo principal: Preto mais escuro */
            color: #ecf0f1; /* Texto claro para contraste geral */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: #0d0d0d; /* Cabeçalho: Preto quase absoluto */
            color: #ecf0f1;
            padding: 15px 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* Sombra mais forte no fundo escuro */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        /* 1) Ajuste: Texto do Relógio da janela principal do tamanho do título */
        #currentTimeMain {
            font-size: 1.8em; /* Match h1 font-size */
            font-weight: bold;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr; /* Três colunas: esquerda, centro (maior), direita */
            gap: 20px;
            flex-grow: 1;
        }

        .column {
            background-color: #2a2a2a; /* Fundo das colunas: Cinzento escuro */
            color: #ecf0f1; /* Texto dentro das colunas: claro */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        /* Novo estilo para o container da lista de participantes */
        .participant-list-container {
            display: flex; /* Permite que as sub-colunas fiquem lado a lado */
            gap: 20px; /* Espaçamento entre as sub-colunas */
            flex-grow: 1; /* Ocupa o espaço disponível */
            overflow-y: hidden; /* Remove o scroll COMPLETAMENTE */
            /* A altura será controlada pelos elementos internos para caberem 6 por coluna */
        }
        
        /* Estilos para as sub-colunas de participantes */
        .participant-sub-column {
            display: flex;
            flex-direction: column;
            flex: 1; /* Faz com que cada sub-coluna ocupe o mesmo espaço */
            min-width: 0; /* Permite o encolhimento correto em telas pequenas */
        }

        h2 {
            color: #ffffff; /* Títulos dentro das colunas: Branco puro */
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4em;
            border-bottom: 2px solid #555; /* Linha de separação mais escura */
            padding-bottom: 10px;
        }
        
        /* Ajuste: Estilo para o cabeçalho da lista de participantes para incluir o botão "Limpar Lista" e "Ativar Modo Debate" */
        .participant-list-header {
            display: flex;
            justify-content: space-between; /* Espalha os itens */
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            /* NOVO: Permite alinhar os botões à direita */
            flex-wrap: wrap; /* Permite quebrar linha em telas pequenas */
            gap: 10px; /* Espaçamento entre o título e os botões, e entre os botões */
        }
        .participant-list-header h2 {
            margin: 0;
            border-bottom: none; /* Remove a borda duplicada do h2 interno */
            padding-bottom: 0;
            /* NOVO: Permite que o h2 ocupe espaço livre e empurre botões para a direita */
            flex-grow: 1; 
        }
        /* NOVO: Agrupa os botões para que fiquem juntos à direita */
        .participant-list-header .header-buttons {
            display: flex;
            gap: 8px; /* Espaçamento entre os botões */
            flex-shrink: 0; /* Impede que o grupo de botões encolha */
        }

        /* Estilo para os botões específicos no header da lista */
        #clearAllParticipantsButton,
        #toggleDebateModeBtn { /* Aplicar estilo a ambos os botões */
            background-color: #e74c3c; /* Vermelho para ação de apagar */
            padding: 8px 12px; /* Menor para caber ao lado do título */
            font-size: 0.9em;
            margin-top: 0; /* Remove a margem superior automática */
            width: auto; /* Deixa a largura automática */
        }
        #toggleDebateModeBtn {
            background-color: #8e44ad; /* Uma cor diferente para o modo debate, ex: roxo */
        }
        #clearAllParticipantsButton:hover {
            background-color: #c0392b;
        }
        #toggleDebateModeBtn:hover {
            background-color: #6c3483;
        }


        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #bdc3c7; /* Rótulos dos campos: cinzento claro */
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #555; /* Borda dos inputs: cinzento */
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            color: #ecf0f1; /* Texto digitado nos inputs: claro */
            background-color: #3a3a3a; /* Fundo dos inputs: cinzento mais escuro */
        }

        /* Botoes de adição (na coluna da esquerda) */
        .button-group button {
            padding: 8px 12px; /* Reduz padding */
            font-size: 0.9em; /* Reduz fonte */
        }

        button {
            background-color: #3498db; /* Azul padrão para botões */
            color: white;
            padding: 10px 15px; /* Padding padrão para a maioria dos botões */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            margin-right: 5px;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #555; /* Botões desabilitados mais escuros */
            cursor: not-allowed;
            color: #999;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .participant-card {
            background-color: #3a3a3a; /* Fundo das cards de participante: Cinzento escuro */
            border: 1px solid #777; /* Borda das cards: cinzento */
            padding: 10px; /* AUMENTADO LIGEIRAMENTE: Mais padding para 6 por coluna */
            margin-bottom: 8px; /* AUMENTADO LIGEIRAMENTE: Mais margem inferior */
            border-radius: 4px; 
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease;
            position: relative;
            flex-shrink: 0; /* Impede que a card encolha */
        }

        .participant-card.active-timer {
            border: 2px solid #28a745; /* Borda verde para timer ativo */
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
            transform: translateY(-3px);
        }

        .participant-line-1 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px; /* AUMENTADO LIGEIRAMENTE: Mais margem inferior */
        }

        .participant-name-container {
            font-weight: bold;
            font-size: 1em; /* AUMENTADO LIGEIRAMENTE: Nome um pouco maior */
            color: #ffffff; /* Nome do participante: branco */
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding-right: 8px; /* AUMENTADO LIGEIRAMENTE */
        }

        .display {
            font-size: 1.5em; /* AUMENTADO LIGEIRAMENTE: Display de tempo um pouco maior */
            font-weight: bold;
            padding: 5px 10px; /* AUMENTADO LIGEIRAMENTE: Mais padding */
            border-radius: 4px; /* AUMENTADO LIGEIRAMENTE */
            min-width: 90px; /* AUMENTADO LIGEIRAMENTE: Largura mínima maior */
            text-align: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Cores dos displays dos temporizadores (mantidas claras para visibilidade) */
        .display.green { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .display.yellow { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        .display.red { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        .participant-line-2-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap; /* Impede quebras de linha nos botões de controle */
            gap: 5px; /* AUMENTADO LIGEIRAMENTE: Mais espaço entre botões */
        }

        .participant-line-2-buttons .controls button,
        .participant-line-2-buttons .adjust-time-buttons button {
            padding: 6px 8px; /* AUMENTADO LIGEIRAMENTE: Padding para os botões internos da card */
            font-size: 0.8em; /* AUMENTADO LIGEIRAMENTE: Fonte para os botões internos da card */
            margin-right: 0; /* Remove margem extra */
        }

        .participant-line-2-buttons .controls button#pause { background-color: #ffc107; }
        .participant-line-2-buttons .controls button#reset { background-color: #dc3545; }
        .participant-line-2-buttons .adjust-time-buttons button { background-color: #6c757d; }

        .remove-participant-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px; /* AUMENTADO LIGEIRAMENTE: Botão de remover maior */
            height: 25px; /* AUMENTADO LIGEIRAMENTE */
            font-size: 0.9em; /* AUMENTADO LIGEIRAMENTE */
            line-height: 1;
            text-align: center;
            padding: 0;
            flex-shrink: 0;
            align-self: center; /* Centraliza verticalmente com os outros botões */
            margin-left: 8px; /* Mais espaço à esquerda */
        }
        .remove-participant-btn:hover {
            background-color: #c82333;
        }

        #noParticipantsMessage {
            text-align: center;
            color: #bdc3c7;
            padding: 10px;
            border: 1px dashed #555;
            border-radius: 5px;
            margin-top: 10px;
            background-color: #2a2a2a;
            display: none;
            font-size: 0.9em;
        }

        .session-controls {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }

        .session-controls select {
            width: calc(100% - 22px);
            margin-right: 0;
            margin-bottom: 8px;
        }
        .session-controls button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        .popout-control {
            margin-top: 15px;
            padding-top: 10px;
            text-align: center;
        }
        .popout-control button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* Mensagem do Palestrante movida para baixo do botão Abrir Ecrã do Palestrante */
        .message-box {
            margin-top: 15px; /* Adiciona margem entre o botão popout e a mensagem */
            border-top: 1px solid #555; /* Adiciona a borda de separação aqui */
            padding-top: 15px;
            /* Removed margin-top: auto; to keep it below the popout-control */
        }
        .message-box button {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        textarea#speakerMessageInput {
            margin-bottom: 8px;
            padding: 8px;
            font-size: 0.9em;
        }

        /* NOVO: Estilos para a secção de Histórico */
        #historySection {
            margin-top: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        #historyList {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto; /* Permite scroll se o histórico for longo */
            max-height: 400px; /* Limita a altura para evitar que o histórico ocupe toda a coluna */
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            padding: 10px;
        }

        #historyList li {
            background-color: #3a3a3a;
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        #historyList li:last-child {
            margin-bottom: 0;
        }

        #historyList li .history-name {
            font-weight: bold;
            color: #ffffff;
            flex-grow: 1;
            margin-right: 10px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        #historyList li .history-time {
            color: #bdc3c7;
            flex-shrink: 0;
            font-weight: bold;
        }
        
        #clearHistoryButton {
            background-color: #e74c3c;
            margin-top: 10px;
            width: 100%;
            font-size: 0.9em;
            padding: 8px 12px;
        }
        #clearHistoryButton:hover {
            background-color: #c0392b;
        }

        /* Responsividade básica */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .column {
                margin-bottom: 20px;
            }
            .participant-list-container {
                flex-direction: column;
                overflow-y: auto; /* Reativa o scroll para telas pequenas */
                max-height: 400px; /* Define um max-height para evitar que a lista ocupe toda a tela */
            }
        }
        /* Ajuste para telas menores no header dos participantes */
        @media (max-width: 768px) {
            .participant-list-header {
                flex-direction: column; /* Empilha o título e os botões em colunas */
                align-items: flex-start; /* Alinha tudo à esquerda */
            }
            .participant-list-header h2 {
                margin-bottom: 10px; /* Espaço entre o título e os botões */
            }
            .participant-list-header .header-buttons {
                width: 100%; /* Ocupa a largura total */
                justify-content: flex-start; /* Alinha os botões à esquerda */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Gestor de Tempo de Conferência</h1>
        <div id="currentTimeMain">00:00:00</div>
    </header>

    <div class="main-layout">
        <div class="column">
            <h2>Adicionar Participante</h2>
            <div class="form-group">
                <label for="participantName">Nome do Palestrante:</label>
                <input type="text" id="participantName" placeholder="Ex: João Silva">
            </div>
            <div class="form-group">
                <label for="initialMinutes">Tempo Inicial (Minutos:Segundos):</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" id="initialMinutes" value="0" min="0" max="999" placeholder="Minutos" style="width: 50%;">
                    <input type="number" id="initialSeconds" value="0" min="0" max="59" placeholder="Segundos" style="width: 50%;">
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="add1Minute">+1 Min</button>
                    <button id="add5Minutes">+5 Min</button>
                    <button id="add10Minutes">+10 Min</button>
                    <button id="add30Minutes">+30 Min</button>
                    <button id="clearTimeInputsBtn" style="background-color: #e74c3c;">Limpar Tempo</button>
                </div>
            </div>
            <button id="addParticipantButton">Adicionar Participante</button>
            
            <div class="session-controls">
                <h2>Configurações de Alerta</h2>
                <div class="form-group">
                    <label for="yellowTime">Tempo para Alerta Amarelo (segundos):</label>
                    <input type="number" id="yellowTime" value="60" min="0">
                </div>
                <div class="form-group">
                    <label for="redTime">Tempo para Alerta Vermelho (segundos):</label>
                    <input type="number" id="redTime" value="10" min="0">
                </div>
            </div>
        </div>

        <div class="column" style="flex-grow: 1;">
           <div class="participant-list-header">
                <h2>Participantes Ativos</h2>
                <div class="header-buttons">
                    <button id="toggleDebateModeBtn">Ativar Modo Debate</button> 
                    <button id="clearAllParticipantsButton">Limpar Lista</button>
                </div>
            </div>
            <div class="participant-list-container">
                <div class="participant-sub-column" id="participantColumn1">
                    <p id="noParticipantsMessage">Nenhum participante adicionado ainda.</p>
                </div>
                <div class="participant-sub-column" id="participantColumn2">
                    </div>
            </div>
        </div>

        <div class="column">
            <div class="session-controls">
                <h2>Sessões</h2>
                <div class="form-group">
                    <label for="sessionNameInput">Nome da Sessão:</label>
                    <input type="text" id="sessionNameInput" placeholder="Nome para salvar a sessão">
                    <button id="saveSessionButton">Salvar Sessão</button>
                </div>
                <div class="form-group">
                    <label for="loadSessionSelect">Carregar Sessão:</label>
                    <select id="loadSessionSelect">
                        <option value="">-- Selecione uma sessão --</option>
                    </select>
                    <div class="button-group">
                        <button id="loadSelectedSessionButton">Carregar</button>
                        <button id="deleteSelectedSessionButton" style="background-color: #e74c3c;">Apagar</button>
                    </div>
                </div>
            </div>

            <div class="popout-control">
                <h2>Ecrã do Palestrante (Pop-up)</h2>
                <button id="openPopoutClockBtn">Abrir Ecrã do Palestrante</button>
            </div>
            <div class="message-box">
                <h2>Mensagem para o Palestrante</h2>
                <textarea id="speakerMessageInput" rows="3" placeholder="Digite uma mensagem para aparecer no ecrã do palestrante..."></textarea>
                <div class="button-group">
                    <button id="sendMessageButton">Enviar Mensagem</button>
                    <button id="clearMessageButton" style="background-color: #e74c3c;">Limpar Mensagem</button>
                </div>
            </div>

            <div class="session-controls" id="historySection">
                <h2>Histórico de Tempos</h2>
                <ul id="historyList">
                    <p id="noHistoryMessage" style="color: #bdc3c7; text-align: center; font-size: 0.9em;">Nenhum registo no histórico.</p>
                </ul>
                <button id="clearHistoryButton">Limpar Histórico</button>
            </div>
        </div>
    </div>
<script>
    const participantNameInput = document.getElementById('participantName');
    const initialMinutesInput = document.getElementById('initialMinutes');
    const initialSecondsInput = document.getElementById('initialSeconds');
    const addParticipantButton = document.getElementById('addParticipantButton');
    const participantColumn1 = document.getElementById('participantColumn1');
    const participantColumn2 = document.getElementById('participantColumn2');
    const noParticipantsMessage = document.getElementById('noParticipantsMessage');

    const openPopoutClockBtn = document.getElementById('openPopoutClockBtn');
    const toggleDebateModeBtn = document.getElementById('toggleDebateModeBtn');

    const add1MinuteBtn = document.getElementById('add1Minute');
    const add5MinutesBtn = document.getElementById('add5Minutes');
    const add10MinutesBtn = document.getElementById('add10Minutes');
    const add30MinutesBtn = document.getElementById('add30Minutes');
    const clearTimeInputsBtn = document.getElementById('clearTimeInputsBtn');

    const yellowTimeInput = document.getElementById('yellowTime');
    const redTimeInput = document.getElementById('redTime');

    const speakerMessageInput = document.getElementById('speakerMessageInput');
    const sendMessageButton = document.getElementById('sendMessageButton');
    const clearMessageButton = document.getElementById('clearMessageButton');

    const currentTimeMain = document.getElementById('currentTimeMain');

    const sessionNameInput = document.getElementById('sessionNameInput');
    const saveSessionButton = document.getElementById('saveSessionButton');
    const loadSessionSelect = document.getElementById('loadSessionSelect');
    const loadSelectedSessionButton = document.getElementById('loadSelectedSessionButton');
    const deleteSelectedSessionButton = document.getElementById('deleteSelectedSessionButton');

    const clearAllParticipantsButton = document.getElementById('clearAllParticipantsButton');

    // NOVO: Elementos do Histórico
    const historyList = document.getElementById('historyList');
    const noHistoryMessage = document.getElementById('noHistoryMessage');
    const clearHistoryButton = document.getElementById('clearHistoryButton');

    let timers = [];
    let nextParticipantNumber = 1;
    let activeTimer = null;
    let popoutWindow = null;
    let popoutReady = false;
    let pendingPopoutUpdate = null;
    let pendingMessageUpdate = null;

    let GLOBAL_YELLOW_THRESHOLD_SECONDS = 60;
    let GLOBAL_RED_THRESHOLD_SECONDS = 10;

    let conferenceSessions = {};
    // NOVO: Array para o histórico de tempos
    let timeHistory = [];

    const PARTICIPANTS_PER_COLUMN = 6;

    // NOVO: Variável para controlar o Modo Debate
    let isDebateModeActive = false;

    // Event Listeners para botões de histórico
    clearHistoryButton.addEventListener('click', clearHistory);

    function formatTime(seconds) {
        const isNegative = seconds < 0;
        const absSeconds = Math.abs(seconds);
        const minutes = Math.floor(absSeconds / 60);
        const remainingSeconds = absSeconds % 60;
        const sign = isNegative ? '-' : '';
        return `${sign}${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    function calculateTotalSeconds(minutes, seconds) {
        return (parseInt(minutes) || 0) * 60 + (parseInt(seconds) || 0);
    }

    function getDisplayColorCustom(timeLeft, yellow, red) {
        yellow = yellow !== undefined ? yellow : GLOBAL_YELLOW_THRESHOLD_SECONDS;
        red = red !== undefined ? red : GLOBAL_RED_THRESHOLD_SECONDS;

        if (timeLeft <= red) {
            return 'red';
        } else if (timeLeft <= yellow) {
            return 'yellow';
        } else {
            return 'green';
        }
    }

    function updateCurrentTimeMain() {
        const now = new Date();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        currentTimeMain.textContent = `${hours}:${minutes}:${seconds}`;
    }

    function addParticipant(data = {}, fromSession = false) {
        let name = data.name || participantNameInput.value.trim();
        const minutesValue = parseInt(initialMinutesInput.value);
        const secondsValue = parseInt(initialSecondsInput.value);
        
        if (!fromSession) {
            const totalEnteredSeconds = calculateTotalSeconds(initialMinutesInput.value, initialSecondsInput.value);
            if (totalEnteredSeconds <= 0 && name === '') {
                return;
            }
            if (isNaN(minutesValue) && isNaN(secondsValue) && name === '') {
                    return;
            }
        }
        
        let initialTotalSeconds = data.initialTime || calculateTotalSeconds(initialMinutesInput.value, initialSecondsInput.value);
        let customYellow = data.yellow;
        let customRed = data.red;

        if (!name) {
            name = `Participante ${nextParticipantNumber}`;
            if (!fromSession) {
                    nextParticipantNumber++;
            }
        } else if (!fromSession) {
              const match = name.match(/Participante (\d+)/);
              if (match && parseInt(match[1]) >= nextParticipantNumber) {
                  nextParticipantNumber = parseInt(match[1]) + 1;
              } else if (!match) {
                  nextParticipantNumber++;
              }
        }

        noParticipantsMessage.style.display = 'none';

        const id = Date.now() + Math.floor(Math.random() * 1000); 
        const participantCard = document.createElement('div');
        participantCard.className = 'participant-card';
        participantCard.setAttribute('data-id', id);

        participantCard.innerHTML = `
            <div class="participant-line-1">
                <div class="participant-name-container">${name}</div>
                <div class="display" id="display-${id}">${formatTime(initialTotalSeconds)}</div>
            </div>
            <div class="participant-line-2-buttons">
                <div class="controls">
                    <button id="start-${id}">Inic.</button>
                    <button id="pause-${id}" disabled>Pausar</button>
                    <button id="reset-${id}" disabled>Reset</button>
                </div>
                <div class="adjust-time-buttons">
                    <button id="add-min-${id}">+1min</button>
                    <button id="sub-min-${id}">-1min</button>
                </div>
                <button class="remove-participant-btn" data-id="${id}">X</button>
            </div>
        `;

        if (timers.length < PARTICIPANTS_PER_COLUMN) {
            participantColumn1.appendChild(participantCard);
        } else {
            participantColumn2.appendChild(participantCard);
        }

        const timer = {
            id: id,
            name: name,
            initialTime: initialTotalSeconds,
            timeLeft: initialTotalSeconds,
            intervalId: null,
            isPaused: true,
            displayElement: document.getElementById(`display-${id}`),
            startButton: document.getElementById(`start-${id}`),
            pauseButton: document.getElementById(`pause-${id}`),
            resetButton: document.getElementById(`reset-${id}`),
            addMinButton: document.getElementById(`add-min-${id}`),
            subMinButton: document.getElementById(`sub-min-${id}`),
            cardElement: participantCard,
            alertedZero: false,
            yellowThreshold: customYellow !== undefined ? customYellow : GLOBAL_YELLOW_THRESHOLD_SECONDS,
            redThreshold: customRed !== undefined ? customRed : GLOBAL_RED_THRESHOLD_SECONDS
        };

        timers.push(timer);

        timer.startButton.addEventListener('click', () => startTimer(timer));
        timer.pauseButton.addEventListener('click', () => pauseTimer(timer));
        timer.resetButton.addEventListener('click', () => resetTimer(timer));
        timer.addMinButton.addEventListener('click', () => adjustTime(timer, 60));
        timer.subMinButton.addEventListener('click', () => adjustTime(timer, -60));
        participantCard.querySelector('.remove-participant-btn').addEventListener('click', () => removeParticipant(id));

        timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));

        if (!fromSession) {
            initialMinutesInput.value = '0'; 
            initialSecondsInput.value = '0'; 
            participantNameInput.value = '';
        }
        updateAllTimerButtons(); // Atualiza botões após adicionar um participante
    }

    function updateAllTimerButtons() {
        timers.forEach(t => {
            if (activeTimer && activeTimer.id === t.id) {
                // Timer ativo: Start desabilitado, Pausar e Reset habilitados
                toggleTimerButtons(t, true, false, false);
                t.addMinButton.disabled = false;
                t.subMinButton.disabled = false;
            } else {
                // Outros timers: Start habilitado, Pausar e Reset desabilitados
                toggleTimerButtons(t, false, true, true);
                // Botões de ajuste de tempo habilitados apenas se o timer não estiver a correr e não for o timer ativo
                t.addMinButton.disabled = !t.isPaused || (activeTimer !== null);
                t.subMinButton.disabled = !t.isPaused || (activeTimer !== null);
            }
        });
    }


    function toggleTimerButtons(timer, startDisabled, pauseDisabled, resetDisabled) {
        if (timer) {
            timer.startButton.disabled = startDisabled;
            timer.pauseButton.disabled = pauseDisabled;
            timer.resetButton.disabled = resetDisabled;
        }
    }

    function adjustTime(timer, secondsToAdd) {
        // Permite ajuste se for o timer ativo OU se não houver timer ativo e este estiver parado
        if ((activeTimer && activeTimer.id === timer.id) || (!activeTimer && timer.isPaused)) {
            timer.timeLeft += secondsToAdd;
            if (timer.timeLeft < -5940) { // Limite de -99:00
                timer.timeLeft = -5940;
            }
            timer.displayElement.textContent = formatTime(timer.timeLeft);
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
            timer.alertedZero = false;
            updateClocks(timer);
        }
    }

    function startTimer(timerToStart) {
        if (timerToStart.isPaused) {
            if (activeTimer && activeTimer.id !== timerToStart.id) {
                pauseTimer(activeTimer); // Pausa o timer atualmente ativo
                activeTimer.cardElement.classList.remove('active-timer');
                // Adiciona o timer pausado ao histórico se terminou o seu tempo
                if (activeTimer.timeLeft <= 0) {
                     addToHistory(activeTimer.name, activeTimer.initialTime, activeTimer.timeLeft);
                }
            } else if (activeTimer && activeTimer.id === timerToStart.id && !activeTimer.isPaused) {
                // Se já é o timer ativo e não está pausado, não faz nada
                return;
            }

            activeTimer = timerToStart;
            activeTimer.cardElement.classList.add('active-timer');

            timerToStart.isPaused = false;
            
            updateAllTimerButtons();

            updateClocks(timerToStart); // Atualiza o pop-up

            timerToStart.intervalId = setInterval(() => {
                timerToStart.timeLeft--;
                timerToStart.displayElement.textContent = formatTime(timerToStart.timeLeft);

                timerToStart.displayElement.classList.remove('red', 'yellow', 'green');
                timerToStart.displayElement.classList.add(getDisplayColorCustom(timerToStart.timeLeft, timerToStart.yellowThreshold, timerToStart.redThreshold));

                updateClocks(timerToStart); // Atualiza o pop-up a cada segundo
            }, 1000);
        }
    }

    function pauseTimer(timerToPause) {
        if (!timerToPause.isPaused) {
            timerToPause.isPaused = true;
            clearInterval(timerToPause.intervalId);
            updateAllTimerButtons();
            updateClocks(timerToPause); // Atualiza o pop-up
        }
    }

    function resetTimer(timerToReset) {
        clearInterval(timerToReset.intervalId);
        timerToReset.isPaused = true;

        // NOVO: Adiciona ao histórico antes de resetar o tempo
        addToHistory(timerToReset.name, timerToReset.initialTime, timerToReset.timeLeft);

        timerToReset.timeLeft = timerToReset.initialTime;
        timerToReset.displayElement.textContent = formatTime(timerToReset.timeLeft);

        timerToReset.displayElement.classList.remove('red', 'yellow', 'green');
        timerToReset.displayElement.classList.add(getDisplayColorCustom(timerToReset.timeLeft, timerToReset.yellowThreshold, timerToReset.redThreshold));
        
        timerToReset.alertedZero = false;
        if (activeTimer && activeTimer.id === timerToReset.id) {
            activeTimer = null; // Remove o timer ativo se for este a ser resetado
            timerToReset.cardElement.classList.remove('active-timer');
            clearClocksFocus(); // Se o ativo for resetado, limpa o foco no pop-up
        }
        updateAllTimerButtons(); // Se não for o ativo, apenas atualiza botões
    }

    function removeParticipant(id) {
        timers = timers.filter(timer => {
            if (timer.id === id) {
                clearInterval(timer.intervalId);
                // NOVO: Se o participante removido for o ativo, ele também é "resetado" e vai para o histórico
                if (activeTimer && activeTimer.id === timer.id) {
                    addToHistory(timer.name, timer.initialTime, timer.timeLeft);
                    activeTimer = null; // Limpa o timer ativo
                    clearClocksFocus();
                } else if (timer.isPaused && timer.timeLeft !== timer.initialTime) {
                    // Se um timer que não está ativo, mas que já foi iniciado/pausado é removido, vai para o histórico
                     addToHistory(timer.name, timer.initialTime, timer.timeLeft);
                }
                timer.cardElement.remove();
                return false;
            }
            return true;
        });

        reorderParticipantsInColumns();

        if (timers.length === 0) {
            noParticipantsMessage.style.display = 'block';
            nextParticipantNumber = 1; // Reinicia a contagem de participantes
        } else {
            let maxNum = 0;
            timers.forEach(timer => {
                const match = timer.name.match(/Participante (\d+)/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) {
                        maxNum = num;
                    }
                }
            });
            nextParticipantNumber = maxNum + 1;
        }
        updateAllTimerButtons();
        updateClocks(activeTimer); // Atualiza o pop-up após remover
    }

    function reorderParticipantsInColumns() {
        participantColumn1.innerHTML = '';
        participantColumn2.innerHTML = '';
        
        if (timers.length === 0) {
            participantColumn1.appendChild(noParticipantsMessage);
            noParticipantsMessage.style.display = 'block';
        } else {
            noParticipantsMessage.style.display = 'none';
        }

        timers.forEach((timer, index) => {
            if (index < PARTICIPANTS_PER_COLUMN) {
                participantColumn1.appendChild(timer.cardElement);
            } else {
                participantColumn2.appendChild(timer.cardElement);
            }
        });
    }

    // NOVO: Funções para o Histórico
    function addToHistory(name, initialTime, finalTime) {
        const timeSpent = initialTime - finalTime;
        const endedOnTime = finalTime >= 0; // True se o tempo final for 0 ou positivo

        timeHistory.unshift({ // Adiciona no início da lista
            name: name,
            timeSpent: timeSpent,
            endedOnTime: endedOnTime,
            timestamp: new Date().toLocaleString('pt-PT') // Data e hora atual
        });
        renderHistory();
        saveHistory();
    }

    function renderHistory() {
        historyList.innerHTML = ''; // Limpa a lista atual

        if (timeHistory.length === 0) {
            historyList.appendChild(noHistoryMessage);
            noHistoryMessage.style.display = 'block';
        } else {
            noHistoryMessage.style.display = 'none';
            timeHistory.forEach(record => {
                const listItem = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'history-name';
                nameSpan.textContent = record.name;

                const timeSpan = document.createElement('span');
                timeSpan.className = 'history-time';
                // Formato: HH:MM para tempo gasto, ou se terminou no negativo, o tempo final
                const displayTime = record.endedOnTime ? formatTime(record.timeSpent) : `-${formatTime(Math.abs(record.finalTime))}`;
                timeSpan.textContent = `Tempo: ${formatTime(record.timeSpent)} (${record.endedOnTime ? 'Concluiu' : 'Esgotado'})`;
                
                listItem.appendChild(nameSpan);
                listItem.appendChild(timeSpan);
                historyList.appendChild(listItem);
            });
        }
    }

    function clearHistory() {
        if (confirm('Tem certeza de que deseja limpar todo o histórico?')) {
            timeHistory = [];
            renderHistory();
            saveHistory();
        }
    }

    function saveHistory() {
        localStorage.setItem('conferenceTimeHistory', JSON.stringify(timeHistory));
    }

    function loadHistory() {
        const savedHistory = localStorage.getItem('conferenceTimeHistory');
        if (savedHistory) {
            timeHistory = JSON.parse(savedHistory);
            renderHistory();
        } else {
            noHistoryMessage.style.display = 'block';
        }
    }


    // Funções de comunicação com o pop-up
    function openPopoutClock() {
        if (popoutWindow && !popoutWindow.closed) {
            popoutWindow.focus();
            return;
        }

        popoutWindow = window.open('popout-clock.html', 'PopoutClock', 'width=800,height=600,resizable,scrollbars=no');
        if (popoutWindow) {
            popoutWindow.focus();
            popoutReady = false;
            pendingPopoutUpdate = null; // Limpa qualquer atualização pendente
            pendingMessageUpdate = null; // Limpa qualquer mensagem pendente
        } else {
            alert('Falha ao abrir a janela pop-up. Por favor, verifique se os bloqueadores de pop-up estão desativados.');
        }
    }

    function updateClocks(currentActiveTimer) {
        if (!popoutWindow || popoutWindow.closed || !popoutReady) {
            // Se a janela não está pronta, armazena a atualização para quando estiver
            if (isDebateModeActive) {
                 pendingPopoutUpdate = { type: 'updateAllClocks', timers: getSimplifiedTimersData() };
            } else if (currentActiveTimer) {
                pendingPopoutUpdate = {
                    type: 'updateClock',
                    name: currentActiveTimer.name,
                    timeLeft: currentActiveTimer.timeLeft,
                    color: getDisplayColorCustom(currentActiveTimer.timeLeft, currentActiveTimer.yellowThreshold, currentActiveTimer.redThreshold),
                    isPaused: currentActiveTimer.isPaused
                };
            } else {
                pendingPopoutUpdate = { type: 'updateClock', name: 'Nenhum Ativo', timeLeft: 0, color: 'green', isPaused: true };
            }
            return;
        }

        if (isDebateModeActive) {
            popoutWindow.postMessage({ type: 'updateAllClocks', timers: getSimplifiedTimersData() }, window.location.origin);
        } else if (currentActiveTimer) {
            popoutWindow.postMessage({
                type: 'updateClock',
                name: currentActiveTimer.name,
                timeLeft: currentActiveTimer.timeLeft,
                color: getDisplayColorCustom(currentActiveTimer.timeLeft, currentActiveTimer.yellowThreshold, currentActiveTimer.redThreshold),
                isPaused: currentActiveTimer.isPaused
            }, window.location.origin);
        } else {
            popoutWindow.postMessage({ type: 'updateClock', name: 'Nenhum Ativo', timeLeft: 0, color: 'green', isPaused: true }, window.location.origin);
        }

        // Se houver uma mensagem pendente, envie-a também
        if (speakerMessageInput.value.trim() !== '') {
            sendMessageToPopout(speakerMessageInput.value.trim());
        } else {
            // Se não houver mensagem, garantir que o popout também está vazio
            sendMessageToPopout('');
        }
    }

    // NOVO: Função para obter dados simplificados dos timers para o modo debate
    function getSimplifiedTimersData() {
        return timers.map(timer => ({
            id: timer.id,
            name: timer.name,
            timeLeft: timer.timeLeft,
            color: getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold),
            isActive: activeTimer && activeTimer.id === timer.id // Indica se este timer é o ativo
        }));
    }

    function clearClocksFocus() {
        activeTimer = null;
        updateAllTimerButtons();
        updateClocks(null); // Envia dados nulos para limpar o foco no pop-up
    }

    function sendMessageToPopout(message) {
        if (!popoutWindow || popoutWindow.closed || !popoutReady) {
            pendingMessageUpdate = message;
            return;
        }
        popoutWindow.postMessage({ type: 'updateMessage', message: message }, window.location.origin);
    }

    // Gerenciamento de Sessões
    function saveConferenceSession() {
        const sessionName = sessionNameInput.value.trim();
        if (!sessionName) {
            alert('Por favor, insira um nome para a sessão.');
            return;
        }

        if (conferenceSessions[sessionName] && !confirm(`Uma sessão com o nome "${sessionName}" já existe. Deseja sobrescrevê-la?`)) {
            return;
        }

        // Mapeia os timers para um formato que possa ser salvo (sem referências DOM ou funções)
        const sessionTimers = timers.map(timer => ({
            id: timer.id, // Manter o ID para facilitar a restauração
            name: timer.name,
            initialTime: timer.initialTime,
            timeLeft: timer.timeLeft, // Salva o tempo restante atual
            isPaused: timer.isPaused, // Salva o estado de pausa
            yellowThreshold: timer.yellowThreshold,
            redThreshold: timer.redThreshold
        }));

        conferenceSessions[sessionName] = {
            timers: sessionTimers,
            globalYellow: yellowTimeInput.value,
            globalRed: redTimeInput.value,
            isDebateModeActive: isDebateModeActive // Salva o estado do modo debate
        };

        localStorage.setItem('conferenceSessions', JSON.stringify(conferenceSessions));
        populateSessionSelect();
        alert(`Sessão "${sessionName}" salva com sucesso!`);
    }

    function loadConferenceSession() {
        const selectedSessionName = loadSessionSelect.value;
        if (!selectedSessionName) {
            alert('Por favor, selecione uma sessão para carregar.');
            return;
        }

        if (confirm('Carregar esta sessão irá limpar todos os participantes atuais. Deseja continuar?')) {
            // Limpa todos os timers atuais e seus intervalos
            timers.forEach(timer => {
                clearInterval(timer.intervalId);
                timer.cardElement.remove();
            });
            timers = [];
            activeTimer = null;
            nextParticipantNumber = 1; // Reseta a contagem de participantes

            clearClocksFocus(); // Limpa o pop-up
            noParticipantsMessage.style.display = 'block';

            const sessionData = conferenceSessions[selectedSessionName];
            if (sessionData) {
                // Restaura as configurações globais de alerta
                yellowTimeInput.value = sessionData.globalYellow;
                redTimeInput.value = sessionData.globalRed;
                GLOBAL_YELLOW_THRESHOLD_SECONDS = parseInt(yellowTimeInput.value);
                GLOBAL_RED_THRESHOLD_SECONDS = parseInt(redTimeInput.value);

                // NOVO: Restaura o estado do modo debate
                isDebateModeActive = sessionData.isDebateModeActive;
                updateDebateModeButtonText(); // Atualiza o texto do botão
                updateClocks(null); // Força atualização do popout para o modo correto

                sessionData.timers.forEach(timerData => {
                    // Recria o participante com os dados salvos
                    addParticipant({
                        name: timerData.name,
                        initialTime: timerData.initialTime,
                        yellow: timerData.yellowThreshold,
                        red: timerData.redThreshold
                    }, true); // Passa true para fromSession
                    
                    // Encontra o timer recém-adicionado pelo ID para restaurar o timeLeft e isPaused
                    const newTimer = timers.find(t => t.id === timerData.id);
                    if (newTimer) {
                        newTimer.timeLeft = timerData.timeLeft;
                        newTimer.isPaused = timerData.isPaused;
                        newTimer.displayElement.textContent = formatTime(newTimer.timeLeft);
                        newTimer.displayElement.classList.remove('red', 'yellow', 'green');
                        newTimer.displayElement.classList.add(getDisplayColorCustom(newTimer.timeLeft, newTimer.yellowThreshold, newTimer.redThreshold));
                        // Se o timer estava ativo na sessão salva e não estava pausado, reativa-o
                        if (timerData.id === sessionData.activeTimerId && !timerData.isPaused) {
                            startTimer(newTimer);
                        } else {
                            // Se não era o ativo ou estava pausado, garantir que os botões estão corretos
                            updateAllTimerButtons();
                        }
                    }
                });
                reorderParticipantsInColumns(); // Garante que estejam nas colunas corretas
                updateAllTimerButtons(); // Garante que os botões de todos os timers estão no estado correto
                alert(`Sessão "${selectedSessionName}" carregada com sucesso!`);
            } else {
                alert('Sessão não encontrada.');
            }
        }
    }

    function deleteConferenceSession() {
        const selectedSessionName = loadSessionSelect.value;
        if (!selectedSessionName) {
            alert('Por favor, selecione uma sessão para apagar.');
            return;
        }

        if (confirm(`Tem certeza de que deseja apagar a sessão "${selectedSessionName}"?`)) {
            delete conferenceSessions[selectedSessionName];
            localStorage.setItem('conferenceSessions', JSON.stringify(conferenceSessions));
            populateSessionSelect();
            alert(`Sessão "${selectedSessionName}" apagada com sucesso!`);
        }
    }

    function populateSessionSelect() {
        loadSessionSelect.innerHTML = '<option value="">-- Selecione uma sessão --</option>';
        const savedSessions = localStorage.getItem('conferenceSessions');
        if (savedSessions) {
            conferenceSessions = JSON.parse(savedSessions);
            for (const name in conferenceSessions) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                loadSessionSelect.appendChild(option);
            }
        }
    }

    // NOVO: Função para alternar o Modo Debate
    function toggleDebateMode() {
        isDebateModeActive = !isDebateModeActive;
        updateDebateModeButtonText();
        updateClocks(activeTimer); // Envia atualização para o pop-up
        if (isDebateModeActive) {
            // Em modo debate, pausar qualquer timer ativo na janela principal
            if (activeTimer) {
                pauseTimer(activeTimer);
            }
        }
        // No modo debate, todos os timers na janela principal devem ter botões de ajuste desabilitados
        // e todos devem ter botões Start/Pause/Reset desabilitados
        timers.forEach(t => {
            t.startButton.disabled = true;
            t.pauseButton.disabled = true;
            t.resetButton.disabled = true;
            t.addMinButton.disabled = true;
            t.subMinButton.disabled = true;
            t.cardElement.classList.remove('active-timer'); // Remove destaque de ativo
        });
    }

    // NOVO: Função para atualizar o texto do botão do Modo Debate
    function updateDebateModeButtonText() {
        toggleDebateModeBtn.textContent = isDebateModeActive ? 'Desativar Modo Debate' : 'Ativar Modo Debate';
        toggleDebateModeBtn.style.backgroundColor = isDebateModeActive ? '#e74c3c' : '#8e44ad';
        toggleDebateModeBtn.style.color = isDebateModeActive ? 'white' : 'white';
    }


    // Event Listeners
    addParticipantButton.addEventListener('click', () => addParticipant());
    openPopoutClockBtn.addEventListener('click', openPopoutClock);
    sendMessageButton.addEventListener('click', () => sendMessageToPopout(speakerMessageInput.value.trim()));
    clearMessageButton.addEventListener('click', () => {
        speakerMessageInput.value = '';
        sendMessageToPopout('');
    });
    yellowTimeInput.addEventListener('change', (e) => {
        GLOBAL_YELLOW_THRESHOLD_SECONDS = parseInt(e.target.value) || 0;
        timers.forEach(timer => {
            timer.yellowThreshold = GLOBAL_YELLOW_THRESHOLD_SECONDS;
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
        });
        updateClocks(activeTimer);
    });
    redTimeInput.addEventListener('change', (e) => {
        GLOBAL_RED_THRESHOLD_SECONDS = parseInt(e.target.value) || 0;
        timers.forEach(timer => {
            timer.redThreshold = GLOBAL_RED_THRESHOLD_SECONDS;
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
        });
        updateClocks(activeTimer);
    });

    // Adição de tempo para inputs
    add1MinuteBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 1);
    add5MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 5);
    add10MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 10);
    add30MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 30);
    clearTimeInputsBtn.addEventListener('click', () => {
        initialMinutesInput.value = '0';
        initialSecondsInput.value = '0';
    });

    saveSessionButton.addEventListener('click', saveConferenceSession);
    loadSelectedSessionButton.addEventListener('click', loadConferenceSession);
    deleteSelectedSessionButton.addEventListener('click', deleteConferenceSession);
    clearAllParticipantsButton.addEventListener('click', () => {
        if (confirm('Tem certeza que deseja limpar todos os participantes da lista?')) {
            timers.forEach(timer => clearInterval(timer.intervalId)); // Para todos os intervalos
            timers = []; // Limpa o array de timers
            activeTimer = null; // Reinicia o timer ativo
            nextParticipantNumber = 1; // Reinicia a contagem de participantes
            participantColumn1.innerHTML = '';
            participantColumn2.innerHTML = '';
            noParticipantsMessage.style.display = 'block';
            updateAllTimerButtons(); // Garante que os botões estão no estado correto
            clearClocksFocus(); // Limpa o pop-up
        }
    });

    // NOVO: Event listener para o botão de alternar modo debate
    toggleDebateModeBtn.addEventListener('click', toggleDebateMode);

    // Receber mensagens do pop-up
    window.addEventListener('message', (event) => {
        const isLocalOrigin = ['null', window.location.origin].includes(event.origin);
        if (!isLocalOrigin && !event.origin.startsWith('file://')) {
            console.warn('Main: Mensagem bloqueada de origem desconhecida:', event.origin);
            return;
        }

        if (event.data.type === 'popoutReady') {
            popoutReady = true;
            // Se houver uma atualização pendente, envie-a agora
            if (pendingPopoutUpdate) {
                if (pendingPopoutUpdate.type === 'updateAllClocks') {
                    popoutWindow.postMessage(pendingPopoutUpdate, window.location.origin);
                } else if (pendingPopoutUpdate.type === 'updateClock') {
                    popoutWindow.postMessage(pendingPopoutUpdate, window.location.origin);
                }
                pendingPopoutUpdate = null; // Limpa após o envio
            }
            // Se houver uma mensagem pendente, envie-a agora
            if (pendingMessageUpdate !== null) {
                sendMessageToPopout(pendingMessageUpdate);
                pendingMessageUpdate = null; // Limpa após o envio
            } else if (speakerMessageInput.value.trim() !== '') {
                // Se não havia mensagem pendente mas há texto no input, envie
                sendMessageToPopout(speakerMessageInput.value.trim());
            } else {
                // Se não há mensagem pendente e o input está vazio, limpe o popout
                sendMessageToPopout('');
            }
        } else if (event.data.type === 'popoutClosed') {
            popoutReady = false;
            popoutWindow = null;
        }
    });

    // Initial setup
    document.addEventListener('DOMContentLoaded', () => {
        updateCurrentTimeMain();
        setInterval(updateCurrentTimeMain, 1000);
        populateSessionSelect();
        loadHistory(); // Carrega o histórico ao iniciar
        updateDebateModeButtonText(); // Define o texto inicial do botão do modo debate
    });

</script>
</body>
</html>
