<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Tempo de Conferência</title>
<style>
        /* CSS para o tema ALL-BLACK */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a; /* Fundo principal: Preto mais escuro */
            color: #ecf0f1; /* Texto claro para contraste geral */
            display: flex;
            flex-direction: column;
            min-height: 10vh;
        }

        header {
            background-color: #0d0d0d; /* Cabeçalho: Preto quase absoluto */
            color: #ecf0f1;
            padding: 15px 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* Sombra mais forte no fundo escuro */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        /* 1) Ajuste: Texto do Relógio da janela principal do tamanho do título */
        #currentTimeMain {
            font-size: 1.8em; /* Match h1 font-size */
            font-weight: bold;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr; /* Três colunas: esquerda, centro (maior), direita */
            gap: 20px;
            flex-grow: 1;
        }

        .column {
            background-color: #2a2a2a; /* Fundo das colunas: Cinzento escuro */
            color: #ecf0f1; /* Texto dentro das colunas: claro */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        /* Novo estilo para o container da lista de participantes */
        .participant-list-container {
            display: flex; /* Permite que as sub-colunas fiquem lado a lado */
            gap: 20px; /* Espaçamento entre as sub-colunas */
            flex-grow: 1; /* Ocupa o espaço disponível */
            overflow-y: hidden; /* Remove o scroll COMPLETAMENTE */
            /* A altura será controlada pelos elementos internos para caberem 6 por coluna */
        }
        
        /* Estilos para as sub-colunas de participantes */
        .participant-sub-column {
            display: flex;
            flex-direction: column;
            flex: 1; /* Faz que cada sub-coluna ocupe o mesmo espaço */
            min-width: 0; /* Permite o encolhimento correto em telas pequenas */
        }

        h2 {
            color: #ffffff; /* Títulos dentro das colunas: Branco puro */
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4em;
            border-bottom: 2px solid #555; /* Linha de separação mais escura */
            padding-bottom: 10px;
        }
        
        /* Ajuste: Estilo para o cabeçalho da lista de participantes para incluir o botão "Limpar Lista" e "Ativar Modo Debate" */
        .participant-list-header {
            display: flex;
            justify-content: space-between; /* Espalha os itens */
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            /* NOVO: Permite alinhar os botões à direita */
            flex-wrap: wrap; /* Permite quebrar linha em telas pequenas */
            gap: 10px; /* Espaçamento entre o título e os botões, e entre os botões */
        }
        .participant-list-header h2 {
            margin: 0;
            border-bottom: none; /* Remove a borda duplicada do h2 interno */
            padding-bottom: 0;
            /* NOVO: Permite que o h2 ocupe espaço livre e empurre botões para a direita */
            flex-grow: 1; 
        }
        /* NOVO: Agrupa os botões para que fiquem juntos à direita */
        .participant-list-header .header-buttons {
            display: flex;
            gap: 8px; /* Espaçamento entre os botões */
            flex-shrink: 0; /* Impede que o grupo de botões encolha */
        }

        /* Estilos para os botões específicos no header da lista */
        #clearAllParticipantsButton,
        #toggleDebateModeBtn { /* Aplicar estilo a ambos os botões */
            background-color: #e74c3c; /* Vermelho para ação de apagar */
            padding: 8px 12px; /* Menor para caber ao lado do título */
            font-size: 0.9em;
            margin-top: 0; /* Remove a margem superior automática */
            width: auto; /* Deixa a largura automática */
        }
        #toggleDebateModeBtn {
            background-color: #8e44ad; /* Uma cor diferente para o modo debate, ex: roxo */
        }
        #clearAllParticipantsButton:hover {
            background-color: #c0392b;
        }
        #toggleDebateModeBtn:hover {
            background-color: #6c3483;
        }


        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #bdc3c7; /* Rótulos dos campos: cinzento claro */
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #555; /* Borda dos inputs: cinzento */
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            color: #ecf0f1; /* Texto digitado nos inputs: claro */
            background-color: #3a3a3a; /* Fundo dos inputs: cinzento mais escuro */
        }

        /* Botoes de adição (na coluna da esquerda) */
        .button-group button {
            padding: 8px 12px; /* Reduz padding */
            font-size: 0.9em; /* Reduz fonte */
        }

        button {
            background-color: #3498db; /* Azul padrão para botões */
            color: white;
            padding: 10px 15px; /* Padding padrão para a maioria dos botões */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            margin-right: 5px;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #555; /* Botões desabilitados mais escuros */
            cursor: not-allowed;
            color: #999;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .participant-card {
            background-color: #3a3a3a; /* Fundo das cards de participante: Cinzento escuro */
            border: 1px solid #777; /* Borda das cards: cinzento */
            padding: 10px; /* AUMENTADO LIGEIRAMENTE: Mais padding para 6 por coluna */
            margin-bottom: 8px; /* AUMENTADO LIGEIRAMENTE: Mais margem inferior */
            border-radius: 4px; 
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease;
            position: relative;
            flex-shrink: 0; /* Impede que a card encolha */
        }

        .participant-card.active-timer {
            border: 2px solid #28a745; /* Borda verde para timer ativo */
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
            transform: translateY(-3px);
        }

        .participant-line-1 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px; /* AUMENTADO LIGEIRAMENTE: Mais margem inferior */
        }

        .participant-name-container {
            font-weight: bold;
            font-size: 1em; /* AUMENTADO LIGEIRAMENTE: Nome um pouco maior */
            color: #ffffff; /* Nome do participante: branco */
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding-right: 8px; /* AUMENTADO LIGEIRAMENTE */
        }

        .display {
            font-size: 1.5em; /* AUMENTADO LIGEIRAMENTE: Display de tempo um pouco maior */
            font-weight: bold;
            padding: 5px 10px; /* AUMENTADO LIGEIRAMENTE: Mais padding */
            border-radius: 4px; /* AUMENTADO LIGEIRAMENTE */
            min-width: 90px; /* AUMENTADO LIGEIRAMENTE: Largura mínima maior */
            text-align: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Cores dos displays dos temporizadores (mantidas claras para visibilidade) */
        .display.green { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .display.yellow { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        .display.red { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        .participant-line-2-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap; /* Impede quebras de linha nos botões de controle */
            gap: 5px; /* AUMENTADO LIGEIRAMENTE: Mais espaço entre botões */
        }

        .participant-line-2-buttons .controls button,
        .participant-line-2-buttons .adjust-time-buttons button {
            padding: 6px 8px; /* AUMENTADO LIGEIRAMENTE: Padding para os botões internos da card */
            font-size: 0.8em; /* AUMENTADO LIGEIRAMENTE: Fonte para os botões internos da card */
            margin-right: 0; /* Remove margem extra */
        }

        .participant-line-2-buttons .controls button#pause { background-color: #ffc107; }
        .participant-line-2-buttons .controls button#reset { background-color: #dc3545; }
        .participant-line-2-buttons .adjust-time-buttons button { background-color: #6c757d; }

        .remove-participant-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px; /* AUMENTADO LIGEIRAMENTE: Botão de remover maior */
            height: 25px; /* AUMENTADO LIGEIRAMENTE */
            font-size: 0.9em; /* AUMENTADO LIGEIRAMENTE */
            line-height: 1;
            text-align: center;
            padding: 0;
            flex-shrink: 0;
            align-self: center; /* Centraliza verticalmente com os outros botões */
            margin-left: 8px; /* Mais espaço à esquerda */
        }
        .remove-participant-btn:hover {
            background-color: #c82333;
        }

        #noParticipantsMessage {
            text-align: center;
            color: #bdc3c7;
            padding: 10px;
            border: 1px dashed #555;
            border-radius: 5px;
            margin-top: 10px;
            background-color: #2a2a2a;
            display: none;
            font-size: 0.9em;
        }

        .session-controls {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }

        .session-controls select {
            width: calc(100% - 22px);
            margin-right: 0;
            margin-bottom: 8px;
        }
        .session-controls button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        .popout-control {
            margin-top: 15px;
            padding-top: 10px;
            text-align: center;
        }
        .popout-control button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        /* Mensagem do Palestrante movida para baixo do botão Abrir Ecrã do Palestrante */
        .message-box {
            margin-top: 15px; /* Adiciona margem entre o botão popout e a mensagem */
            border-top: 1px solid #555; /* Adiciona a borda de separação aqui */
            padding-top: 15px;
            /* Removed margin-top: auto; to keep it below the popout-control */
        }
        .message-box button {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        textarea#speakerMessageInput {
            margin-bottom: 8px;
            padding: 8px;
            font-size: 0.9em;
        }

        /* NOVO: Estilos para a secção de Histórico */
        #historySection {
            margin-top: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        #historyList {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto; /* Permite scroll se o histórico for longo */
            max-height: 400px; /* Limita a altura para evitar que o histórico ocupe toda a coluna */
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            padding: 10px;
        }

        #historyList li {
            background-color: #3a3a3a;
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        #historyList li:last-child {
            margin-bottom: 0;
        }

        #historyList li .history-name {
            font-weight: bold;
            color: #ffffff;
            flex-grow: 1;
            margin-right: 10px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        #historyList li .history-time {
            color: #bdc3c7;
            flex-shrink: 0;
            font-weight: bold;
        }
        
        #clearHistoryButton {
            background-color: #e74c3c;
            margin-top: 10px;
            width: 100%;
            font-size: 0.9em;
            padding: 8px 12px;
        }
        #clearHistoryButton:hover {
            background-color: #c0392b;
        }

        /* Responsividade básica */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .column {
                margin-bottom: 20px;
            }
            .participant-list-container {
                flex-direction: column;
                overflow-y: auto; /* Reativa o scroll para telas pequenas */
                max-height: 400px; /* Define um max-height para evitar que a lista ocupe toda a tela */
            }
        }
        /* Ajuste para telas menores no header dos participantes */
        @media (max-width: 768px) {
            .participant-list-header {
                flex-direction: column; /* Empilha o título e os botões em colunas */
                align-items: flex-start; /* Alinha tudo à esquerda */
            }
            .participant-list-header h2 {
                margin-bottom: 10px; /* Espaço entre o título e os botões */
            }
            .participant-list-header .header-buttons {
                width: 100%; /* Ocupa a largura total */
                justify-content: flex-start; /* Alinha os botões à esquerda */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Gestor de Tempo de Conferência</h1>
        <div id="currentTimeMain">00:00:00</div>
    </header>

    <div class="main-layout">
        <div class="column">
            <h2>Adicionar Participante</h2>
            <div class="form-group">
                <label for="participantName">Nome do Palestrante:</label>
                <input type="text" id="participantName" placeholder="Ex: João Silva">
            </div>
            <div class="form-group">
                <label for="initialMinutes">Tempo Inicial (Minutos:Segundos):</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" id="initialMinutes" value="0" min="0" max="999" placeholder="Minutos" style="width: 50%;">
                    <input type="number" id="initialSeconds" value="0" min="0" max="59" placeholder="Segundos" style="width: 50%;">
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="add1Minute">+1 Min</button>
                    <button id="add5Minutes">+5 Min</button>
                    <button id="add10Minutes">+10 Min</button>
                    <button id="add30Minutes">+30 Min</button>
                    <button id="clearTimeInputsBtn" style="background-color: #e74c3c;">Limpar Tempo</button>
                </div>
            </div>
            <button id="addParticipantButton">Adicionar Participante</button>
            
            <div class="session-controls">
                <h2>Configurações de Alerta</h2>
                <div class="form-group">
                    <label for="yellowTime">Tempo para Alerta Amarelo (segundos):</label>
                    <input type="number" id="yellowTime" value="60" min="0">
                </div>
                <div class="form-group">
                    <label for="redTime">Tempo para Alerta Vermelho (segundos):</label>
                    <input type="number" id="redTime" value="10" min="0">
                </div>
            </div>
        </div>

        <div class="column" style="flex-grow: 1;">
           <div class="participant-list-header">
                <h2>Participantes Ativos</h2>
                <div class="header-buttons">
                    <button id="toggleDebateModeBtn">Ativar Modo Debate</button> 
                    <button id="clearAllParticipantsButton">Limpar Lista</button>
                </div>
            </div>
            <div class="participant-list-container">
                <div class="participant-sub-column" id="participantColumn1">
                    <p id="noParticipantsMessage">Nenhum participante adicionado ainda.</p>
                </div>
                <div class="participant-sub-column" id="participantColumn2">
                    </div>
            </div>
        </div>

        <div class="column">
            <div class="session-controls">
                <h2>Sessões</h2>
                <div class="form-group">
                    <label for="sessionNameInput">Nome da Sessão:</label>
                    <input type="text" id="sessionNameInput" placeholder="Nome para salvar a sessão">
                    <button id="saveSessionButton">Salvar Sessão</button>
                </div>
                <div class="form-group">
                    <label for="loadSessionSelect">Carregar Sessão:</label>
                    <select id="loadSessionSelect">
                        <option value="">-- Selecione uma sessão --</option>
                    </select>
                    <div class="button-group">
                        <button id="loadSelectedSessionButton">Carregar</button>
                        <button id="deleteSelectedSessionButton" style="background-color: #e74c3c;">Apagar</button>
                    </div>
                </div>
            </div>

            <div class="popout-control">
                <h2>Ecrã do Palestrante (Pop-up)</h2>
                <button id="openPopoutClockBtn">Abrir Ecrã do Palestrante</button>
            </div>
            <div class="message-box">
                <h2>Mensagem para o Palestrante</h2>
                <textarea id="speakerMessageInput" rows="3" placeholder="Digite uma mensagem para aparecer no ecrã do palestrante..."></textarea>
                <div class="button-group">
                    <button id="sendMessageButton">Enviar Mensagem</button>
                    <button id="clearMessageButton" style="background-color: #e74c3c;">Limpar Mensagem</button>
                </div>
            </div>

            <div class="session-controls" id="historySection">
                <h2>Histórico de Tempos</h2>
                <ul id="historyList">
                    <p id="noHistoryMessage" style="color: #bdc3c7; text-align: center; font-size: 0.9em;">Nenhum registo no histórico.</p>
                </ul>
                <button id="clearHistoryButton">Limpar Histórico</button>
            </div>
        </div>
    </div>
<script>
    const participantNameInput = document.getElementById('participantName');
    const initialMinutesInput = document.getElementById('initialMinutes');
    const initialSecondsInput = document.getElementById('initialSeconds');
    const addParticipantButton = document.getElementById('addParticipantButton');
    const participantColumn1 = document.getElementById('participantColumn1');
    const participantColumn2 = document.getElementById('participantColumn2');
    const noParticipantsMessage = document.getElementById('noParticipantsMessage');

    const openPopoutClockBtn = document.getElementById('openPopoutClockBtn');
    const toggleDebateModeBtn = document.getElementById('toggleDebateModeBtn');

    const add1MinuteBtn = document.getElementById('add1Minute');
    const add5MinutesBtn = document.getElementById('add5Minutes');
    const add10MinutesBtn = document.getElementById('add10Minutes');
    const add30MinutesBtn = document.getElementById('add30Minutes');
    const clearTimeInputsBtn = document.getElementById('clearTimeInputsBtn');

    const yellowTimeInput = document.getElementById('yellowTime');
    const redTimeInput = document.getElementById('redTime');

    const speakerMessageInput = document.getElementById('speakerMessageInput');
    const sendMessageButton = document.getElementById('sendMessageButton');
    const clearMessageButton = document.getElementById('clearMessageButton');

    const currentTimeMain = document.getElementById('currentTimeMain');

    const sessionNameInput = document.getElementById('sessionNameInput');
    const saveSessionButton = document.getElementById('saveSessionButton');
    const loadSessionSelect = document.getElementById('loadSessionSelect');
    const loadSelectedSessionButton = document.getElementById('loadSelectedSessionButton');
    const deleteSelectedSessionButton = document.getElementById('deleteSelectedSessionButton');

    const clearAllParticipantsButton = document.getElementById('clearAllParticipantsButton');

    // Elementos do Histórico
    const historyList = document.getElementById('historyList');
    const noHistoryMessage = document.getElementById('noHistoryMessage');
    const clearHistoryButton = document.getElementById('clearHistoryButton');

    let timers = [];
    let nextParticipantNumber = 1;
    let activeTimer = null;
    let popoutWindow = null;
    let popoutReady = false;
    let GLOBAL_YELLOW_THRESHOLD_SECONDS = 60;
    let GLOBAL_RED_THRESHOLD_SECONDS = 10;
    let conferenceSessions = {};
    let timeHistory = [];
    let isDebateModeActive = false; // Variável para controlar o Modo Debate

    const PARTICIPANTS_PER_COLUMN = 6;

    // --- Funções Auxiliares ---
    function formatTime(seconds) {
        const isNegative = seconds < 0;
        const absSeconds = Math.abs(seconds);
        const minutes = Math.floor(absSeconds / 60);
        const remainingSeconds = absSeconds % 60;
        const sign = isNegative ? '-' : '';
        return `${sign}${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    function calculateTotalSeconds(minutes, seconds) {
        return (parseInt(minutes) || 0) * 60 + (parseInt(seconds) || 0);
    }

    function getDisplayColorCustom(timeLeft, yellow, red) {
        yellow = yellow !== undefined ? yellow : GLOBAL_YELLOW_THRESHOLD_SECONDS;
        red = red !== undefined ? red : GLOBAL_RED_THRESHOLD_SECONDS;

        if (timeLeft <= red) {
            return 'red';
        } else if (timeLeft <= yellow) {
            return 'yellow';
        } else {
            return 'green';
        }
    }

    function updateCurrentTimeMain() {
        const now = new Date();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        currentTimeMain.textContent = `${hours}:${minutes}:${seconds}`;
    }

    // --- Gestão de Participantes e Timers ---
    function addParticipant(data = {}, fromSession = false) {
        let name = data.name || participantNameInput.value.trim();
        const minutesValue = parseInt(initialMinutesInput.value);
        const secondsValue = parseInt(initialSecondsInput.value);
        
        if (!fromSession) {
            const totalEnteredSeconds = calculateTotalSeconds(initialMinutesInput.value, initialSecondsInput.value);
            if (totalEnteredSeconds <= 0 && name === '') {
                return;
            }
            if (isNaN(minutesValue) && isNaN(secondsValue) && name === '') {
                    return;
            }
        }
        
        let initialTotalSeconds = data.initialTime || calculateTotalSeconds(initialMinutesInput.value, initialSecondsInput.value);
        let customYellow = data.yellowThreshold; // Use yellowThreshold from data
        let customRed = data.redThreshold;     // Use redThreshold from data

        if (!name) {
            name = `Participante ${nextParticipantNumber}`;
            if (!fromSession) { // Só incrementa se não for carregado de uma sessão
                nextParticipantNumber++;
            }
        } else if (!fromSession) {
              const match = name.match(/Participante (\d+)/);
              if (match && parseInt(match[1]) >= nextParticipantNumber) {
                  nextParticipantNumber = parseInt(match[1]) + 1;
              } else if (!match) { // Se o nome não for do padrão "Participante X", incrementa
                  nextParticipantNumber++;
              }
        }


        noParticipantsMessage.style.display = 'none';

        const id = Date.now() + Math.floor(Math.random() * 1000); 
        const participantCard = document.createElement('div');
        participantCard.className = 'participant-card';
        participantCard.setAttribute('data-id', id);

        participantCard.innerHTML = `
            <div class="participant-line-1">
                <div class="participant-name-container">${name}</div>
                <div class="display" id="display-${id}">${formatTime(initialTotalSeconds)}</div>
            </div>
            <div class="participant-line-2-buttons">
                <div class="controls">
                    <button id="start-${id}" data-action="start" data-id="${id}">Inic.</button>
                    <button id="pause-${id}" data-action="pause" data-id="${id}" disabled>Pausar</button>
                    <button id="reset-${id}" data-action="reset" data-id="${id}" disabled>Reset</button>
                </div>
                <div class="adjust-time-buttons">
                    <button id="add-min-${id}" data-action="add-min" data-id="${id}">+1min</button>
                    <button id="sub-min-${id}" data-action="sub-min" data-id="${id}">-1min</button>
                </div>
                <button class="remove-participant-btn" data-action="remove" data-id="${id}">X</button>
            </div>
        `;

        const timer = {
            id: id,
            name: name,
            initialTime: initialTotalSeconds,
            timeLeft: data.timeLeft !== undefined ? data.timeLeft : initialTotalSeconds, // Usa timeLeft salvo se existir
            intervalId: null,
            isPaused: data.isPaused !== undefined ? data.isPaused : true, // Usa isPaused salvo se existir
            displayElement: participantCard.querySelector(`#display-${id}`),
            startButton: participantCard.querySelector(`#start-${id}`),
            pauseButton: participantCard.querySelector(`#pause-${id}`),
            resetButton: participantCard.querySelector(`#reset-${id}`),
            addMinButton: participantCard.querySelector(`#add-min-${id}`),
            subMinButton: participantCard.querySelector(`#sub-min-${id}`),
            cardElement: participantCard,
            alertedZero: false,
            yellowThreshold: customYellow !== undefined ? customYellow : GLOBAL_YELLOW_THRESHOLD_SECONDS,
            redThreshold: customRed !== undefined ? customRed : GLOBAL_RED_THRESHOLD_SECONDS
        };

        timers.push(timer);
        reorderParticipantsInColumns(); // Adiciona o card à coluna correta e reordena

        timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));

        // Se o timer foi carregado de uma sessão e estava ativo, reativá-lo
        if (data.isActive && !timer.isPaused) {
            startTimer(timer); // Isso também cuidará de pausar o anterior, se houver
        } else {
            updateAllTimerButtons(); // Atualiza o estado dos botões para todos os timers
        }

        if (!fromSession) {
            initialMinutesInput.value = '0'; 
            initialSecondsInput.value = '0'; 
            participantNameInput.value = '';
        }
    }

    function updateAllTimerButtons() {
        timers.forEach(t => {
            if (isDebateModeActive) {
                // No modo debate, todos os botões são desabilitados na janela principal
                t.startButton.disabled = true;
                t.pauseButton.disabled = true;
                t.resetButton.disabled = true;
                t.addMinButton.disabled = true;
                t.subMinButton.disabled = true;
                t.cardElement.classList.remove('active-timer'); // Remove destaque
            } else if (activeTimer && activeTimer.id === t.id) {
                // Timer ativo no modo normal: Start desabilitado, Pausar e Reset habilitados
                t.startButton.disabled = true;
                t.pauseButton.disabled = false;
                t.resetButton.disabled = false;
                t.addMinButton.disabled = false;
                t.subMinButton.disabled = false;
                t.cardElement.classList.add('active-timer');
            } else {
                // Outros timers no modo normal: Start habilitado, Pausar e Reset desabilitados
                t.startButton.disabled = false;
                t.pauseButton.disabled = true;
                t.resetButton.disabled = true;
                // Botões de ajuste de tempo habilitados apenas se o timer não estiver a correr e não for o timer ativo
                t.addMinButton.disabled = !t.isPaused || (activeTimer !== null);
                t.subMinButton.disabled = !t.isPaused || (activeTimer !== null);
                t.cardElement.classList.remove('active-timer');
            }
        });
        updateClocks(); // Garante que o pop-up reflete o estado atual dos botões/timers
    }

    function adjustTime(timer, secondsToAdd) {
        // Permite ajuste se for o timer ativo OU se não houver timer ativo E este estiver parado
        if ((activeTimer && activeTimer.id === timer.id) || (!activeTimer && timer.isPaused && !isDebateModeActive)) {
            timer.timeLeft += secondsToAdd;
            if (timer.timeLeft < -5940) { // Limite de -99:00
                timer.timeLeft = -5940;
            }
            timer.displayElement.textContent = formatTime(timer.timeLeft);
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
            timer.alertedZero = false; // Reset alert status
            updateClocks(); // Atualiza o pop-up
        }
    }

    function startTimer(timerToStart) {
        if (isDebateModeActive) return; // Não permite iniciar timers individualmente no modo debate

        if (timerToStart.isPaused) {
            if (activeTimer && activeTimer.id !== timerToStart.id) {
                // Pause the currently active timer and log it to history if applicable
                pauseTimer(activeTimer); 
                if (activeTimer.timeLeft <= 0 || activeTimer.timeLeft !== activeTimer.initialTime) {
                    addToHistory(activeTimer.name, activeTimer.initialTime, activeTimer.timeLeft);
                }
            } else if (activeTimer && activeTimer.id === timerToStart.id && !activeTimer.isPaused) {
                return; // Already running
            }

            activeTimer = timerToStart;
            timerToStart.isPaused = false;
            
            updateAllTimerButtons();

            timerToStart.intervalId = setInterval(() => {
                timerToStart.timeLeft--;
                timerToStart.displayElement.textContent = formatTime(timerToStart.timeLeft);

                timerToStart.displayElement.classList.remove('red', 'yellow', 'green');
                timerToStart.displayElement.classList.add(getDisplayColorCustom(timerToStart.timeLeft, timerToStart.yellowThreshold, timerToStart.redThreshold));

                updateClocks(); // Update pop-up
            }, 1000);
        }
    }

    function pauseTimer(timerToPause) {
        if (!timerToPause.isPaused) {
            timerToPause.isPaused = true;
            clearInterval(timerToPause.intervalId);
            updateAllTimerButtons();
            updateClocks(); // Update pop-up
        }
    }

    function resetTimer(timerToReset) {
        clearInterval(timerToReset.intervalId);
        timerToReset.isPaused = true;

        // Add to history BEFORE resetting time
        addToHistory(timerToReset.name, timerToReset.initialTime, timerToReset.timeLeft);

        timerToReset.timeLeft = timerToReset.initialTime;
        timerToReset.displayElement.textContent = formatTime(timerToReset.timeLeft);

        timerToReset.displayElement.classList.remove('red', 'yellow', 'green');
        timerToReset.displayElement.classList.add(getDisplayColorCustom(timerToReset.timeLeft, timerToReset.yellowThreshold, timerToReset.redThreshold));
        
        timerToReset.alertedZero = false;
        if (activeTimer && activeTimer.id === timerToReset.id) {
            activeTimer = null; // Clear active timer if it was the one being reset
            timerToReset.cardElement.classList.remove('active-timer');
            updateClocks(); // Update pop-up after removing focus
        }
        updateAllTimerButtons(); // Update button states
    }

    function removeParticipant(id) {
        timers = timers.filter(timer => {
            if (timer.id === id) {
                clearInterval(timer.intervalId);
                // If the removed participant was active, log to history
                if (activeTimer && activeTimer.id === timer.id) {
                    addToHistory(timer.name, timer.initialTime, timer.timeLeft);
                    activeTimer = null; // Clear active timer
                } else if (timer.isPaused && timer.timeLeft !== timer.initialTime) {
                    // If a non-active timer that was started/paused is removed, log to history
                     addToHistory(timer.name, timer.initialTime, timer.timeLeft);
                }
                timer.cardElement.remove();
                return false;
            }
            return true;
        });

        reorderParticipantsInColumns();

        if (timers.length === 0) {
            noParticipantsMessage.style.display = 'block';
            nextParticipantNumber = 1; // Reset participant count
        } else {
            // Recalculate nextParticipantNumber based on existing participants
            let maxNum = 0;
            timers.forEach(timer => {
                const match = timer.name.match(/Participante (\d+)/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) {
                        maxNum = num;
                    }
                }
            });
            nextParticipantNumber = maxNum + 1;
        }
        updateAllTimerButtons(); // Update button states and refresh pop-up
    }

    function reorderParticipantsInColumns() {
        // Clear columns first, then re-append based on current timers array
        participantColumn1.innerHTML = '';
        participantColumn2.innerHTML = '';
        
        if (timers.length === 0) {
            participantColumn1.appendChild(noParticipantsMessage);
            noParticipantsMessage.style.display = 'block';
        } else {
            noParticipantsMessage.style.display = 'none';
        }

        timers.forEach((timer, index) => {
            if (index < PARTICIPANTS_PER_COLUMN) {
                participantColumn1.appendChild(timer.cardElement);
            } else {
                participantColumn2.appendChild(timer.cardElement);
            }
        });
    }

    // --- Histórico de Tempos ---
    function addToHistory(name, initialTime, finalTime) {
        const timeSpent = initialTime - finalTime;
        const endedOnTime = finalTime >= 0; // True if final time is 0 or positive

        timeHistory.unshift({ // Add to the beginning of the list
            name: name,
            timeSpent: timeSpent,
            endedOnTime: endedOnTime,
            timestamp: new Date().toLocaleString('pt-PT'),
            finalTime: finalTime // Store final time to accurately represent "over time"
        });
        renderHistory();
        saveHistory();
    }

    function renderHistory() {
        historyList.innerHTML = ''; // Clear current list

        if (timeHistory.length === 0) {
            historyList.appendChild(noHistoryMessage);
            noHistoryMessage.style.display = 'block';
        } else {
            noHistoryMessage.style.display = 'none';
            timeHistory.forEach(record => {
                const listItem = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'history-name';
                nameSpan.textContent = record.name;

                const timeSpan = document.createElement('span');
                timeSpan.className = 'history-time';
                // Format: HH:MM for time spent, or if ended negative, the negative time
                let displayTimeText;
                if (record.finalTime < 0) {
                    displayTimeText = `Esgotado: ${formatTime(record.finalTime)}`; // Shows negative time
                } else {
                    displayTimeText = `Concluiu: ${formatTime(record.timeSpent)}`; // Shows time spent
                }
                timeSpan.textContent = displayTimeText;
                
                listItem.appendChild(nameSpan);
                listItem.appendChild(timeSpan);
                historyList.appendChild(listItem);
            });
        }
    }

    function clearHistory() {
        if (confirm('Tem certeza de que deseja limpar todo o histórico?')) {
            timeHistory = [];
            renderHistory();
            saveHistory();
        }
    }

    function saveHistory() {
        localStorage.setItem('conferenceTimeHistory', JSON.stringify(timeHistory));
    }

    function loadHistory() {
        const savedHistory = localStorage.getItem('conferenceTimeHistory');
        if (savedHistory) {
            timeHistory = JSON.parse(savedHistory);
            renderHistory();
        } else {
            noHistoryMessage.style.display = 'block';
        }
    }

    // --- Comunicação com o Pop-up ---
    function openPopoutClock() {
        if (popoutWindow && !popoutWindow.closed) {
            popoutWindow.focus();
            return;
        }

        popoutWindow = window.open('popout-clock.html', 'PopoutClock', 'width=800,height=600,resizable,scrollbars=no');
        if (popoutWindow) {
            popoutWindow.focus();
            popoutReady = false; // Reset ready state until popout confirms it's ready
        } else {
            // No alert needed, as browser usually handles pop-up blocking feedback
        }
    }

    // Aprimorada: Envia o estado COMPLETO para o pop-up
    function updateClocks() {
        if (!popoutWindow || popoutWindow.closed || !popoutReady) {
            return; // Only send if popout is open and ready
        }

        const dataToSend = {
            type: 'updateAll', // New type to signify a comprehensive update
            isDebateModeActive: isDebateModeActive,
            activeSpeakerName: '',
            activeSpeakerTimeLeft: 0,
            activeSpeakerColor: 'green',
            activeSpeakerIsPaused: true,
            allTimers: [],
            speakerMessage: speakerMessageInput.value.trim(),
            globalYellow: GLOBAL_YELLOW_THRESHOLD_SECONDS,
            globalRed: GLOBAL_RED_THRESHOLD_SECONDS
        };

        if (isDebateModeActive) {
            dataToSend.allTimers = timers.map(timer => ({
                id: timer.id,
                name: timer.name,
                timeLeft: timer.timeLeft,
                color: getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold),
                isActive: activeTimer && activeTimer.id === timer.id // Adiciona esta propriedade
            }));
        } else if (activeTimer) {
            dataToSend.activeSpeakerName = activeTimer.name;
            dataToSend.activeSpeakerTimeLeft = activeTimer.timeLeft;
            dataToSend.activeSpeakerColor = getDisplayColorCustom(activeTimer.timeLeft, activeTimer.yellowThreshold, activeTimer.redThreshold);
            dataToSend.activeSpeakerIsPaused = activeTimer.isPaused;
        } else {
            dataToSend.activeSpeakerName = 'Nenhum Ativo';
            dataToSend.activeSpeakerTimeLeft = 0;
            dataToSend.activeSpeakerColor = 'green';
            dataToSend.activeSpeakerIsPaused = true;
        }

        popoutWindow.postMessage(dataToSend, window.location.origin);
    }

    function sendMessageToPopout() {
        // This function will now simply trigger a full updateClocks,
        // as updateClocks already sends the message state.
        updateClocks();
    }

    // --- Gerenciamento de Sessões ---
    function saveConferenceSession() {
        const sessionName = sessionNameInput.value.trim();
        if (!sessionName) {
            return; // Do nothing if no name
        }

        const sessionTimers = timers.map(timer => ({
            id: timer.id,
            name: timer.name,
            initialTime: timer.initialTime,
            timeLeft: timer.timeLeft,
            isPaused: timer.isPaused,
            yellowThreshold: timer.yellowThreshold,
            redThreshold: timer.redThreshold,
            isActive: activeTimer && activeTimer.id === timer.id // Store if it was the active timer
        }));

        conferenceSessions[sessionName] = {
            timers: sessionTimers,
            globalYellow: yellowTimeInput.value,
            globalRed: redTimeInput.value,
            isDebateModeActive: isDebateModeActive,
            speakerMessage: speakerMessageInput.value.trim() // Save current message
        };

        localStorage.setItem('conferenceSessions', JSON.stringify(conferenceSessions));
        populateSessionSelect();
        // Removed alert
    }

    function loadConferenceSession() {
        const selectedSessionName = loadSessionSelect.value;
        if (!selectedSessionName) {
            return; // Do nothing if no session selected
        }

        // Clear all current timers and their intervals
        timers.forEach(timer => clearInterval(timer.intervalId));
        timers = [];
        activeTimer = null;
        
        // Clear the visual columns
        participantColumn1.innerHTML = '';
        participantColumn2.innerHTML = '';

        noParticipantsMessage.style.display = 'block';

        const sessionData = conferenceSessions[selectedSessionName];
        if (sessionData) {
            // Restore global alert settings
            yellowTimeInput.value = sessionData.globalYellow;
            redTimeInput.value = sessionData.globalRed;
            GLOBAL_YELLOW_THRESHOLD_SECONDS = parseInt(yellowTimeInput.value);
            GLOBAL_RED_THRESHOLD_SECONDS = parseInt(redTimeInput.value);

            // Restore debate mode state
            isDebateModeActive = sessionData.isDebateModeActive;
            updateDebateModeButtonText();

            // Restore speaker message
            speakerMessageInput.value = sessionData.speakerMessage || '';

            // Add participants from session data
            sessionData.timers.forEach(timerData => {
                addParticipant(timerData, true); // Pass true for fromSession
            });
            
            // Re-evaluate the active timer after all participants are added
            const savedActiveTimerData = sessionData.timers.find(t => t.isActive && !t.isPaused);
            if (savedActiveTimerData) {
                activeTimer = timers.find(t => t.id === savedActiveTimerData.id);
                if (activeTimer) {
                    startTimer(activeTimer); // Restart the active timer
                }
            } else {
                updateAllTimerButtons(); // Just update buttons if no active timer
            }

            // Recalculate nextParticipantNumber based on existing participants after loading
            let maxNum = 0;
            timers.forEach(timer => {
                const match = timer.name.match(/Participante (\d+)/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) {
                        maxNum = num;
                    }
                }
            });
            nextParticipantNumber = maxNum + 1;

            updateAllTimerButtons(); // Ensure all buttons are correctly enabled/disabled based on current state
        } else {
            // Removed alert
        }
    }

    function deleteConferenceSession() {
        const selectedSessionName = loadSessionSelect.value;
        if (!selectedSessionName) {
            return; // Do nothing if no session selected
        }

        if (confirm(`Tem certeza de que deseja apagar a sessão "${selectedSessionName}"?`)) {
            delete conferenceSessions[selectedSessionName];
            localStorage.setItem('conferenceSessions', JSON.stringify(conferenceSessions));
            populateSessionSelect();
            // Removed alert
        }
    }

    function populateSessionSelect() {
        loadSessionSelect.innerHTML = '<option value="">-- Selecione uma sessão --</option>';
        const savedSessions = localStorage.getItem('conferenceSessions');
        if (savedSessions) {
            conferenceSessions = JSON.parse(savedSessions);
            for (const name in conferenceSessions) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                loadSessionSelect.appendChild(option);
            }
        }
    }

    // --- Modo Debate ---
    function toggleDebateMode() {
        isDebateModeActive = !isDebateModeActive;
        updateDebateModeButtonText();
        if (isDebateModeActive) {
            // In debate mode, pause any active timer in the main window
            if (activeTimer) {
                pauseTimer(activeTimer);
            }
        }
        updateAllTimerButtons(); // This will also trigger updateClocks()
    }

    function updateDebateModeButtonText() {
        toggleDebateModeBtn.textContent = isDebateModeActive ? 'Desativar Modo Debate' : 'Ativar Modo Debate';
        toggleDebateModeBtn.style.backgroundColor = isDebateModeActive ? '#e74c3c' : '#8e44ad';
        toggleDebateModeBtn.style.color = 'white';
    }


    // --- Delegação de Eventos para Botões de Participantes ---
    // Adicione o listener aos containers pais que não são recriados
    [participantColumn1, participantColumn2].forEach(column => {
        column.addEventListener('click', (event) => {
            const target = event.target;
            const action = target.dataset.action;
            const id = parseInt(target.dataset.id); // Converte para número

            if (!action || isNaN(id)) return; // Se não houver ação ou ID inválido, ignore

            const timer = timers.find(t => t.id === id);
            if (!timer) return; // Se o timer não for encontrado, ignore

            switch (action) {
                case 'start':
                    startTimer(timer);
                    break;
                case 'pause':
                    pauseTimer(timer);
                    break;
                case 'reset':
                    resetTimer(timer);
                    break;
                case 'add-min':
                    adjustTime(timer, 60);
                    break;
                case 'sub-min':
                    adjustTime(timer, -60);
                    break;
                case 'remove':
                    removeParticipant(id);
                    break;
            }
        });
    });


    // --- Outros Event Listeners ---
    addParticipantButton.addEventListener('click', () => addParticipant());
    openPopoutClockBtn.addEventListener('click', openPopoutClock);
    sendMessageButton.addEventListener('click', () => {
        sendMessageToPopout();
        speakerMessageInput.value = ''; // Clear input after sending
        speakerMessageInput.focus(); // Keep focus for quick sending
    });
    clearMessageButton.addEventListener('click', () => {
        speakerMessageInput.value = '';
        sendMessageToPopout(); // Send empty message
    });

    // NOVO: Enviar mensagem ao pressionar "Enter" na textarea
    speakerMessageInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) { // Check for Enter, but not Shift+Enter
            event.preventDefault(); // Prevent new line
            sendMessageButton.click(); // Trigger send message button click
        }
    });

    yellowTimeInput.addEventListener('change', (e) => {
        GLOBAL_YELLOW_THRESHOLD_SECONDS = parseInt(e.target.value) || 0;
        timers.forEach(timer => {
            timer.yellowThreshold = GLOBAL_YELLOW_THRESHOLD_SECONDS;
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
        });
        updateClocks();
    });
    redTimeInput.addEventListener('change', (e) => {
        GLOBAL_RED_THRESHOLD_SECONDS = parseInt(e.target.value) || 0;
        timers.forEach(timer => {
            timer.redThreshold = GLOBAL_RED_THRESHOLD_SECONDS;
            timer.displayElement.classList.remove('red', 'yellow', 'green');
            timer.displayElement.classList.add(getDisplayColorCustom(timer.timeLeft, timer.yellowThreshold, timer.redThreshold));
        });
        updateClocks();
    });

    // Add time buttons for inputs
    add1MinuteBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 1);
    add5MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 5);
    add10MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 10);
    add30MinutesBtn.addEventListener('click', () => initialMinutesInput.value = parseInt(initialMinutesInput.value || 0) + 30);
    clearTimeInputsBtn.addEventListener('click', () => {
        initialMinutesInput.value = '0';
        initialSecondsInput.value = '0';
    });

    saveSessionButton.addEventListener('click', saveConferenceSession);
    loadSelectedSessionButton.addEventListener('click', loadConferenceSession);
    deleteSelectedSessionButton.addEventListener('click', deleteConferenceSession);
    clearAllParticipantsButton.addEventListener('click', () => {
        if (confirm('Tem certeza que deseja limpar todos os participantes da lista?')) {
            timers.forEach(timer => clearInterval(timer.intervalId)); // Stop all intervals
            timers = []; // Clear the timers array
            activeTimer = null; // Reset active timer
            nextParticipantNumber = 1; // Reset participant count
            participantColumn1.innerHTML = '';
            participantColumn2.innerHTML = '';
            noParticipantsMessage.style.display = 'block';
            updateAllTimerButtons(); // Ensure button states are correct
        }
    });

    toggleDebateModeBtn.addEventListener('click', toggleDebateMode);
    clearHistoryButton.addEventListener('click', clearHistory);

    // Receive messages from pop-up
    window.addEventListener('message', (event) => {
        const isLocalOrigin = ['null', window.location.origin].includes(event.origin);
        if (!isLocalOrigin && !event.origin.startsWith('file://')) {
            console.warn('Main: Mensagem bloqueada de origem desconhecida:', event.origin);
            return;
        }

        if (event.data.type === 'popoutReady') {
            popoutReady = true;
            updateClocks(); // Send full state immediately after popout is ready
        } else if (event.data.type === 'popoutClosed') {
            popoutReady = false;
            popoutWindow = null;
        }
    });

    // Initial setup
    document.addEventListener('DOMContentLoaded', () => {
        updateCurrentTimeMain();
        setInterval(updateCurrentTimeMain, 1000);
        populateSessionSelect();
        loadHistory(); // Load history on startup
        updateDebateModeButtonText(); // Set initial text for debate mode button
        updateAllTimerButtons(); // Ensure buttons are in correct state on load
    });

</script>
</body>
</html>
